# 结题报告

## 目录

[结题报告](#结题报告)
- [结题报告](#结题报告)
  - [目录](#目录)
  - [项目介绍](#项目介绍)
  - [小组成员以及分工](#小组成员以及分工)
  - [立项依据](#立项依据)
    - [往年小组项目情况](#往年小组项目情况)
      - [x-DisGraFS 小组：](#x-disgrafs-小组)
      - [x-TOBEDONE 小组](#x-tobedone-小组)
      - [MyGlow 小组：](#myglow-小组)
      - [本组创新方向](#本组创新方向)
    - [Nginx反向代理](#nginx反向代理)
      - [反向代理](#反向代理)
      - [反向代理优势](#反向代理优势)
      - [反向代理应用](#反向代理应用)
    - [向量化索引](#向量化索引)
      - [向量化索引的原理](#向量化索引的原理)
      - [向量化嵌入模型](#向量化嵌入模型)
      - [llamaindex](#llamaindex)
  - [项目设计](#项目设计)
    - [系统架构](#系统架构)
      - [My-Glow小组架构](#my-glow小组架构)
      - [本组架构](#本组架构)
    - [Nginx反向代理](#nginx反向代理-1)
    - [多模态数据打标](#多模态数据打标)
    - [多模态数据生成向量化索引](#多模态数据生成向量化索引)
    - [Neo4j](#neo4j)
      - [图数据库](#图数据库)
        - [定义](#定义)
        - [图数据库的关键概念](#图数据库的关键概念)
      - [Neo4j简介](#neo4j简介)
      - [Neo4j的优点](#neo4j的优点)
      - [使用Neo4j的原因](#使用neo4j的原因)
    - [JuiceFS存储优化](#juicefs存储优化)
      - [JuiceFS是什么](#juicefs是什么)
      - [JuiceFS的特点](#juicefs的特点)
    - [检索方式](#检索方式)
      - [1、直接查看neo4j](#1直接查看neo4j)
      - [2、使用语言搜索](#2使用语言搜索)
        - [流程](#流程)
        - [效果展示](#效果展示)
      - [3、使用图像搜索](#3使用图像搜索)
        - [流程](#流程-1)
        - [效果展示](#效果展示-1)
      - [4、使用文件搜索](#4使用文件搜索)
        - [流程](#流程-2)
        - [效果展示](#效果展示-2)
    - [纠删码和数据一致性等](#纠删码和数据一致性等)
      - [纠删码](#纠删码)
      - [数据一致性](#数据一致性)
  - [效果展示](#效果展示-3)
    - [文件操作界面](#文件操作界面)
    - [可视化界面](#可视化界面)
  - [项目总结](#项目总结)
  - [致谢](#致谢)


## 项目介绍

本项目名为 `VIVO50FS`，全称为 `VIVO50 File System`，是一个支持多种文件类型和搜索模式的的分布式图文件系统。本项目是基于2023年 `My-Glow` 小组项目的优化，主要针对图文件系统中多模态数据的处理和中央服务器的负载均衡问题，尝试使用多模态大模型来生成向量化索引，并尝试利用反向代理优化中央服务器，从而使得该图文件系统可以更好地支持不同格式的文件，并拥有更好的性能。同时，我们小组在优化往年架构的同时，将本地存储优化为在 `JuiceFS` 中存储，还加入了多种检索文件的方式，使得对文件的检索更加准确。

## 小组成员以及分工

- 马耀华：负责my-Glow组storage部分代码理解，辅助部分前端页面修改，存储部分修改，项目运行调试，PPT编写
- 刘畅：负责my-Glow组central-server的代码理解，本组central-server部分和打标部分代码重构，项目运行调试
- 马筱雅：负责my-Glow打标代码理解，打标大模型和向量化大模型寻找，llamaindex和向量化部分代码初步编写，PPT编写
- 吕思源：负责my-Glow打标代码等的理解，central-server部分和向量化部分代码增强，如增加图像检索功能，向量可视化，合并模块等。
- 范明瑞：负责my-Glow组central-server的代码理解，nginx反向代理部署，部分前端页面修改

总之，本小组各个方面几乎都有两人左右参与，前期调研，后期调试等都有大家共同的努力和参与，是大家共同努力的结果。
## 立项依据

### 往年小组项目情况

#### x-DisGraFS 小组：
- x-DisGraFS小组构建了分布式图文件系统，采用Neo4j的图数据库，并且采用分布式存储，和Ray进行分布式计算打标的框架，初步实现图文件系统。

- 它的远程存储集群并没有真正搭建起来，DisGraFS 实际的实现中要求用户要将存储结点挂载到本地，形成一个所谓的客户端，这一项增加了用户的使用难度。
  
#### x-TOBEDONE 小组
- 复用了 dontpanic 的纠删码文件切片设计，改进了多用户隔离，在网页端引入共享、删除、重命名等文件操作，引入了文件夹操作，通过 vpn 搭建 Ray 集群，引入了监控模块，监控数据图形可视化，运维工作者可以远程唤醒或关闭存储结点。用户的所有操作均在网页端进行，也实现了多个模块的容器化部署。 

#### MyGlow 小组：

- 重新搭建了整个分布式框架，并解决了数据一致性问题，提高了系统的鲁棒性。重写了前端和可视化，实现了更好的用户体验。
- 此外，通过更新ray打标的大模型，他们提高了图文件系统的准确性和效率。

#### 本组创新方向
通过对往年小组的分析，我们发现，往年小组的中央服务器并未实现分布式，其中一个或多个主服务器负责管理文件的存储和访问。这种架构存在一些局限性，例如单点故障、性能瓶颈和可扩展性差等。故本组想要分布式处理中央服务器并实现反向代理，从而优化负载均衡问题，并且使用多模态大模型生成向量化索引，更好地支持多种文件格式，使得搜索结果更加准确。

### Nginx反向代理

#### 反向代理

反向代理是一种[代理服务器](https://so.csdn.net/so/search?q=代理服务器&spm=1001.2101.3001.7020)的配置模式，它代表服务器向客户端提供服务。客户端发送请求到反向代理服务器，然后反向代理服务器将请求转发到后端的真实服务器上，并将响应返回给客户端。简单理解为用户直接访问反向代理服务器就可以获得目标服务器的资源。这一过程叫反向代理。

反向代理和正向代理的区别就是：**正向代理代理客户端，反向代理代理服务器。**

反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

下面通过两张图来对比正向代理和方向代理：

[![img](https://camo.githubusercontent.com/056f51397914386190cc08d2ae2b15a44e860862c51ae34815df7982c5ba3a05/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d30653536633235613265626264626462373531376338303238643463396339345f31343430772e77656270)](https://camo.githubusercontent.com/056f51397914386190cc08d2ae2b15a44e860862c51ae34815df7982c5ba3a05/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d30653536633235613265626264626462373531376338303238643463396339345f31343430772e77656270)

[![img](https://camo.githubusercontent.com/17116c1fd72132f429060b3b84ca51c509e8e0c4e220dad3231283a6ddac7e16/68747470733a2f2f706963332e7a68696d672e636f6d2f38302f76322d32666433633538383335303336383062353839326138623865636335376165615f31343430772e77656270)](https://camo.githubusercontent.com/17116c1fd72132f429060b3b84ca51c509e8e0c4e220dad3231283a6ddac7e16/68747470733a2f2f706963332e7a68696d672e636f6d2f38302f76322d32666433633538383335303336383062353839326138623865636335376165615f31343430772e77656270)

　　理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。

　　总结起来还是一句话：**正向代理代理客户端，反向代理代理服务器。**

#### 反向代理优势

nginx反向代理的优点有：

- 可以隐藏后端服务器的真实IP地址，提高安全性。
- 可以实现负载均衡，根据不同的算法，将请求分配给不同的后端服务器，提高性能和可用性。
- 可以实现缓存和压缩，减少网络传输和后端服务器的负担。
- 可以实现URL重写和跳转，根据不同的规则，修改或重定向请求和响应。
- 可以实现日志记录和监控，方便分析和调试。

#### 反向代理应用

1. **负载均衡**：Nginx 可以作为负载均衡器，将客户端请求分发给多个后端服务器，以提高系统的性能、可用性和可扩展性。通过负载均衡，Nginx可以根据不同的策略（如轮询、IP哈希、最少连接数等）将请求分发给不同的后端服务器。
2. **缓存加速**：Nginx 可以缓存静态资源或动态内容，减轻后端服务器的负载并提高用户访问速度。通过在Nginx上设置缓存规则，可以将频繁访问的内容缓存起来，减少对后端服务器的请求次数。
3. **SSL终端**：Nginx 可以作为SSL终端，用于处理SSL/TLS连接。通过在Nginx上进行SSL终端处理，可以减轻后端服务器的负载，并提高安全性。
4. **保护后端服务器**：Nginx可以用作防火墙，过滤和限制对后端服务器的访问。通过Nginx的访问控制功能，可以限制特定IP地址、User-Agent、请求方法等的访问，并保护后端服务器免受恶意攻击。
5. **Web应用代理**：Nginx可以代理各种Web应用程序，如Node.js、Python Django、Ruby on Rails等。通过将客户端请求代理到不同的后端应用服务器，可以实现统一的访问入口和负载均衡。
6. **静态文件服务**：Nginx可以直接提供静态文件服务，无需借助后端应用服务器。这种方式可以降低系统的负载，并提高静态文件的访问速度。

### 向量化索引
#### 向量化索引的原理
向量嵌入只是从图像、文本和音频转换而来的数值表示。在大模型中，"embedding"指的是将某种类型的输入数据（如文本、图像、声音等）转换成一个稠密的数值向量的过程。这些向量通常包含较多维度，每一个维度代表输入数据的某种抽象特征或属性。Embedding 的目的是将实际的输入转化为一种格式，使得计算机能够更有效地处理和学习
- 文本Embedding
 在自然语言处理（NLP）中，文本embedding是一个常见的概念。是将文字或短语转换成数值向量的过程。这些向量捕捉了单词的语义特征，例如意义、上下文关系等。比如，使用词嵌入技术（如Word2Vec、GloVe或BERT），模型可以将具有相似意义的词映射到向量空间中的相近位置。
 - 图像Embedding
 对于图像，embedding过程通常涉及使用卷积神经网络（CNN）等模型来提取图像中的特征，并将这些特征转换为一个高维向量。这样的向量可以代表图像的内容、风格、色彩等信息，从而用于图像识别、分类或检索任务。
 - 声音Embedding
 在声音处理领域，embedding通常指的是将音频信号转换为一个表示其特征的向量，这包括音调、节奏、音色等。通过这样的转换，可以进行声音识别、音乐生成等任务。
2 为什么使用Embedding

Embedding的主要优势是能够将实体转换为计算机易于处理的数值形式，同时减少信息的维度和复杂度。
有助于提高处理效率，而且也使得不同实体之间的比较（如计算相似度）变得可行。
embedding通常通过大量数据的训练而得到，能够捕捉到复杂的模式和深层次的关系，这是传统方法难以实现的
#### 向量化嵌入模型
目前存在大量的支持嵌入的模型，考虑到本项目文件系统中文件类型的多样性，所以考虑采用多模态大模型，因此考虑了一系列大模型
- bge-large-zh1.5模型：bge-large-zh是一个针对中文文本的预训练模型，其核心功能是将文本转换为高维向量表示。这些向量捕捉了文本中的语义信息，使得语义上相似的文本在向量空间中的距离更近。这种表示方法为后续的相似性搜索和聚类提供了便利。主要用于文本嵌入，对于图像的支持度较低
  
- nomicEmbedding 模型：Nomic是一个提供嵌入（embedding）解决方案的公司，专注于将高维数据（如文本、图像等）转化为低维向量空间表示，以便于数据的分析、可视化和处理。Nomic的嵌入服务和工具旨在帮助用户理解和探索他们的数据，特别是在处理大量文本或图像数据时。且提供便捷的API接口，方便开发者将Nomic Embed集成到他们的应用或工作流程中。

- CLIP 模型：由OpenAI开发。同时接受文本和图像输入，并将它们映射到一个共享的嵌入空间中，从而实现多模态对齐。能够处理文本和图像之间的相关任务，如图像搜索和描述生成。
- DashVector：由阿里云开发，可以对音频，图像，文本进行向量嵌入，使用api调用，但没有成熟的与llamaindex交互的案例
- ALIGN (A Large-scale ImaGe and Noisy-text embedding)：由Google提出。利用大规模的图像和文本数据进行联合训练，生成共享的多模态嵌入。适用于图像搜索和描述生成等任务，目前不开源。

#### llamaindex
llamaindex是将大语言模型（Large Language Models, LLMs）和外部数据连接在一起的工具，内部提供了许多链接图数据库与Embedded模型的函数，在不使用llamaindex时，若将一个文件向量化后存入neo4j，则包含load，index， store三个步骤，由于embedded模型一次处理的文件大小有限，所以需要手动对文件进行大小划分成不同节点，而llamaindex提供函数可以帮助我们省去该操作。
例如：
```python
import os
import openai
from llama_index.vector_stores.neo4jvector import Neo4jVectorStore
from llama_index.core import VectorStoreIndex, SimpleDirectoryReader
# 设置embedded模型和数据库
os.environ["OPENAI_API_KEY"] = "OPENAI_API_KEY"
openai.api_key = os.environ["OPENAI_API_KEY"]
username = "neo4j"
password = "pleaseletmein"
url = "bolt://localhost:7687"
embed_dim = 1536
# 初始化数据库
neo4j_vector = Neo4jVectorStore(username, password, url, embed_dim)
# load documents
documents = SimpleDirectoryReader("./data/paul_graham").load_data()
from llama_index.core import StorageContext
# 存储
storage_context = StorageContext.from_defaults(vector_store=neo4j_vector)
# 构建索引
index = VectorStoreIndex.from_documents(
    documents, storage_context=storage_context
)
```




## 项目设计

### 系统架构

#### My-Glow小组架构

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710101634567-2100044869.png)

#### 本组架构

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710101523800-2042913458.png" style="zoom:80%;" />

从这两张图可以看出，我们小组在 `My-Glow` 小组的基础上对于整个文件系统的架构进行了优化。我们在客户端和web服务器之间引入了反向代理，并加入了多个web服务器用来进行负载均衡，还将web服务器和中央服务器合并，这样可以避免在web服务器和中央服务器之间传递文件时产生的时间和资源消耗。同时，打标、建立向量化索引以及检索等一系列操作都放在web服务器中实现。我们还将他们的存储集群改成了juiceFS，同时也保留了 `My-Glow` 小组的纠删码、数据一致性等模块。

### Nginx反向代理

### 多模态数据打标

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710102720224-1098703474.png)

上面是我们小组关于打标模块的示意图。

目前，我们小组支持的文件类型有文本类型、图片类型和音频类型。打标即提取文件关键字的过程，由于图的结构方便展示文件之间的共同点和联系，所以我们仍然保留了这一部分并进行了打标模型的优化。在打标过程中，因为当前大模型对不同文件类型的文件有不同的处理方式，所以首先需要判断文件类型，对于文本和图片类型，可以直接调用讯飞星火大模型进行关键字提取，对于音频类型的文件，需要先转化为文本文件再进行关键字的提取。提取关键词后存入缓冲区，方便后续使用。

**调用后的效果图如下：**
红色部分为文件结点，橙色部分为提取出的关键字结点，可见使用大模型对于文件进行理解的方式可行。
![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710103137356-494677617.png)


### 多模态数据生成向量化索引

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710102913938-63083092.png)
**Embedded大模型的选择**：
    对文件进行向量构建首先需要选择向量化模型，我们尝试过 bgeEmbedding 模型，阿里的 Embedding 模型等，bgeEmbedding 模型本地化部署有较大硬件需求，最终结合对 Embedding 模型支持的文件类型和轻量化的综合考量，选择 NomicEmbedding 模型，该模型支持对文本和图片类型的向量化，并且支持远程api调用，对于音频类型的文件，同样对其转文字后的结果进行操作。

设置好 Embedding 模型后，我们采用 llamaindex和 neo4j 进行交互，直接在 neo4j 中创建包含文件基本信息和向量的结点。

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710103022798-1116178027.png" style="zoom:80%;" />

生成结点的效果如上图，包含了文件名、文件路径、向量、文件类型等多种属性。

### Neo4j

#### 图数据库

##### 定义

图数据库（graph database，GDB）是一种使用图结构进行语义查询的数据库。

数据库中使用结点、边、属性来表示和存储数据。该系统的一个关键概念是图，其将存储中的数据项与数据结点以及结点间表示关系的边的集合进行关联，从而使用结点之间以边相连的图结构进行数据的表示。这些关系使得数据库中的数据直接链接在一起，易于检索。使用图数据库进行数据之间关系的表示非常直观，对于存储高度相连的数据非常有效。

##### 图数据库的关键概念

1. 结点： 结点用来表示实体或者实例，大致相当于关系数据库中的记录。
2. 边： 边位于两个结点之间，用来表示关系。边可以有向可以无向，例如在人际关系图中，有向边可用来表示两个人之间单向相识；在兴趣图中，无向边可以用来表示一个人对某种事件感兴趣。
3. 属性： 属性是结点相关的信息。结点的属性反映了结点的性质与内容，可通过结点的属性进行关系的搭建与搜索。例如在人际关系图中，两个人同时认识一个人，则二人均具有“与某人相识“的属性，并可通过该属性在二人之间进行查找。
4. 路径： 路径由至少一个结点，通过各种关系连接组成，常作为一个查询或者遍历的结果。
5. 遍历： 对图的遍历指根据结点之间的关系，访问到所有的结点

#### Neo4j简介

Neo4j 是一个高性能的 NOSQL 图形数据库，它将结构化数据存储在图上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化高性能引擎，该引擎具有成熟数据库的所有特性。它是一个可扩展、符合 ACID 的图形数据库，采用了高性能分布式集群架构设计，并可用于自托管和云产品。查询语言为cypher，编写语言为java。

#### Neo4j的优点

- 支持多种操作系统；
- 生态较为完整，使用量大，有较多资料和工具；
- 提供多种API接口；
- 层数较低时查找效率可观；

#### 使用Neo4j的原因

对于文件，会在生成向量化索引的同时在 Neo4j 中建立相应结点；对于标签，如果含有该标签的结点不在图数据库中存在，则建立一个新的结点，并把所上传文件的结点和标签结点连边，从而构建图。一个标签结点可以连接多个文件文件，一个文件结点也会与不同的标签结点相连，能够直观展示出各文件之间的关联性和部分主要内容，也体现了图文件系统的优越性。Neo4j 中得到的图会在后面的部分进行展示。因此通过文件结点与标签结点之间的连边，我们可以直观看出文件的主要内容，不同文件之间的关联等等，具有一定的可视性

### JuiceFS存储优化

#### JuiceFS是什么

JuiceFS 是一款面向云原生设计的高性能分布式文件系统，提供了丰富的 API，适用于各种形式数据的管理、分析、归档、备份，可以在不修改代码的前提下无缝对接大数据、机器学习、人工智能等应用平台，为其提供海量、弹性、低价的高性能存储。运维人员不用再为可用性、灾难恢复、监控、扩容等工作烦恼，专注于业务开发，提升研发效率。

#### JuiceFS的特点

1、高性能：分布式多级缓存机制提供弹性扩展的吞吐能力，还能应对数据热点挑战；自研高性能元数据服务每秒可以承载上百万请求、百微秒级时延。

2、操作简单：使用 mount 命令挂载 juiceFS 后，可以直接把  juiceFS 当作本地磁盘使用。在网页端上传文件后，经过打标、构建向量化索引、存入neo4j等一系列过程后，文件就会被存入服务器所在主机挂载的 juiceFS 中，用于后续下载等等操作。

3、自带监控功能：JuiceFS 自带的控制台可以监控存储模块的各项性能，不需要本机再部署复杂的监控模块

4、一致性：分布式系统，往往需要在缓存和一致性之间进行取舍。JuiceFS 由于其元数据分离架构，需要从元数据、文件数据（对象存储）、文件数据本地缓存三方面来思考一致性问题。对于元数据缓存，JuiceFS 默认的挂载设置满足「关闭再打开（close-to-open）」一致性，也就是说一个客户端修改并关闭文件之后，其他客户端重新打开这个文件都会看到最新的修改。与此同时，默认的挂载参数设置了 1 秒的内核元数据缓存，满足了一般场景的需要；对于对象存储，JuiceFS 将文件分成一个个数据块（默认 4MiB），赋予唯一 ID 并上传至对象存储服务。文件的任何修改操作都将生成新的数据块，原有块保持不变，所以不用担心数据缓存的一致性问题，因为一旦文件被修改过了，JuiceFS 会从对象存储读取新的数据块。而老的失效数据块，也会随着回收站或碎片合并机制被删除，避免对象存储泄露；本地数据缓存也是以对象存储的数据块做为最小单元。一旦文件数据被下载到缓存盘，一致性就和缓存盘可靠性相关，如果磁盘数据发生了篡改，客户端也会读取到错误的数据。

### 检索方式

#### 1、直接查看neo4j

点击网页端的 `neo4j`，即可跳转到图数据库的界面进行查看。

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710103137356-494677617.png)

从 `neo4j` 的界面可以清楚的看到，存入文件系统的各个文件之间通过标签相互连接，可以很好地反应文件之间的关系。

#### 2、使用语言搜索

##### 流程

- 获取语言向量

``` python
def IndexSearch(query):
    return VectorSearch(embedding_model.get_query_embedding(query))
```

- 检索文件，计算余弦相似度

- 选择文件并返回到前端

``` python
# 获取所有的文件结点
stored_nodes = neo4j_vector.database_query("MATCH (n:File) RETURN n")
print([_['n']['file_path'] for _ in stored_nodes])

sorted_nodes = sorted(
	stored_nodes,
	reverse = True, 
	key = lambda node : embedding_model.similarity(node['n']['embedding'], query_vector)
)
```

##### 效果展示

查询 `Files related to cats` 得到的结果如下图所示，文件系统会按照相似度从大到小展示十个文件。

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710161952461-2103124481.png)

其中 `cat.txt` 的部分内容为：

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710162224116-43677566.png)

`cat3.png` 的内容为：

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710162431352-384594540.png" style="zoom:67%;" />

可以看出这两个文件和要查询内容的关联度都非常高。

#### 3、使用图像搜索

##### 流程

获取图片向量

``` python
def ImageSearch(image_path):
    return VectorSearch(embedding_model.get_image_embedding(image_path))
```

检索文件，计算余弦相似度

选择文件并返回到前端

``` python
# 获取所有的文件结点
stored_nodes = neo4j_vector.database_query("MATCH (n:File) RETURN n")
print([_['n']['file_path'] for _ in stored_nodes])

sorted_nodes = sorted(
    stored_nodes,
    reverse = True, 
    key = lambda node : embedding_model.similarity(node['n']['embedding'], query_vector)
)
```

##### 效果展示

用来搜索的图片为：

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710162740115-685149089.png" style="zoom:50%;" />

网页端显示的结果为：

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710162828809-1871749128.png)

其中搜索到的第一张图片为：

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710162914408-844332234.png" style="zoom:50%;" />

搜索到的前三张图片和要进行搜索的图片均为毕加索的画作，可以看出这几个图片的关联度都是非常高的。

#### 4、使用文件搜索

##### 流程

选中文件并获取该文件向量，文件可以是文本类型

检索文件，计算余弦相似度

选择文件并返回到前端

##### 效果展示

传入的文件为：

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710163257028-353086079.png" style="zoom:50%;" />

网页端的搜索结果为：

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710163116283-1597968596.png)

搜索得到的第一个文件为：

<img src="https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710163327532-2121090510.png" style="zoom:50%;" />

### 纠删码和数据一致性等

#### 纠删码

纠删码具有如下几个特点：

1、高效的数据保护：纠删码能够在数据丢失的情况下进行数据恢复，并且比传统的复制方法更加高效。通过增加少量的冗余数据，可以在硬件故障或数据损坏时恢复原始数据。

2、节省存储空间：与简单的三副本复制相比，纠删码需要的冗余数据量较少。纠删码可以在需要恢复数据时，仅用少量额外存储来实现与三副本方案相同的可靠性。

3、弹性和可扩展性：纠删码可以应用于不同规模的存储集群，从而提供灵活的保护级别。它们可以根据需要调整编码参数，以适应不同的存储和性能需求。

4、提高数据可靠性和可用性：通过纠删码，可以在数据存储过程中实现更高的可靠性和可用性。即使在多个存储结点发生故障的情况下，系统仍然能够恢复数据。

为了增强文件系统的可用性，我们小组保留了 `My-Glow` 小组的纠删码模块，将文件切片存储在存储模块的不同位置。这样，即使文件系统某一个位置的文件损坏，也能够利用纠删码从其他位置读出完整的文件内容。

#### 数据一致性

分布式系统的数据一致性问题主要是由于分布式系统中的多个结点之间需要进行数据共享和同步，而结点之间的数据和操作是不一致的，从而导致数据不一致的问题。对于 `My-Glow` 小组优化的数据一致性方面，我们也将其保留在了我们的项目之中。

以文件上传的操作为例，具体步骤如下：

1、用户通过网页端选择需要上传的文件，并点击 `upload` 之后，将请求发送给反向代理服务器

2、反向代理服务器根据负载均衡策略将请求转发到对应的服务器

3、服务器向 `JuiceFS` 发送存储文件的命令，此时并不会真正将文件存入 `JuiceFS` 中，而是将文件存入缓冲区，以保证数据一致性

4、服务器调用分布式打标模块，对多模态的数据进行打标，并将打标的结果传回服务器

5、打标成功后服务器尝试连接 `neo4j` 模块，并发送相应的命令

6、`neo4j` 接收到命令后将命令存入缓冲区而不是直接进行操作，并向服务器发送存入缓冲区成功的消息

7、此时如果之前所有的步骤都成功，则服务器开始在各个模块正式写入文件

8、首先调用 index 模块，生成向量化索引，并在 `neo4j`中建立结点

9、接着 `neo4j` 取出缓冲区的命令，根据向量化索引中的结点将文件和标签进行连边

10、将文件利用纠删码模块切片存入 `JuiceFS` 并更改网页端 `JSON` 文件的显示

## 效果展示

详细的效果展示见同目录的 `操作`文件夹下，里面有各种操作的录像。

### 文件操作界面

用户可以在此界面进行文件的上传、下载、删除、搜索等操作。

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710202349401-168168315.png)

### 可视化界面

这个界面直观地反映出各个文件之间的相似度。

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710202210116-1444117989.png)

## 项目总结

本项目是在过去几年内几个OSH项目基础上优化发展而来的。

![](https://img2024.cnblogs.com/blog/1996139/202407/1996139-20240710102439253-1063597540.png)

在往年项目上做优化并不简单，首先需要读明白每个代码以及他们之间的调用关系，然后重写代码，改进架构，在此基础上再去做优化。在这个过程中，小组成员之间的配合非常重要，比如这个项目需要有人做反向代理，有人做前端，有人去重构代码，有人搞部署等等，是我们每个人的共同努力才做到最终的结果。

同时，我们的工作也有一些需要改进的地方。例如对视频类型文件的处理，由于大模型的限制，并不能直接对其生成向量化索引。对此，我们小组提出了如下两个构想，一个是将视频分帧切割后调用存储图片的函数进行处理，但是这样做会使得查找过程比较繁琐，并且也会丢失视频的音频信息；另一个是对视频提取出的关键字进行向量化，这个方法比较依赖打标模型的性能，对关键字提取的准确度要求较高，而且在查找的过程中不能很好地反映视频这一文件类型的特征。这个方面还需要之后的小组再进行改进工作。

## 致谢

感谢刑凯老师参与了本小组选题、可行性、各个阶段的讨论并提出意见和启发性建议，帮助我们确定了项目的方向。

感谢 `My-Glow` 的学长学姐们在我们复现项目时提供的无私帮助，以及本次担任助教的学长的帮助

.
